Redis：内存型数据库；非关系型数据库，远程字典服务；服务器通过网络访问

存储方式：key:value
基本数据结构：String, Hash, List, Set, SortedSet
语法
set key value
get key

linux中使用：
redis-cli -h 127.0.0.1 -9 6379

Java中使用:依赖SDK，类似JDBC
Jedis, Lettuce, Spring Data Redis, Redisson

为什么使用redis：查询速度快很多，缓解数据库查询压力

经典用法：

用户请求  ->  redis   ->  database  <<
分布式管理：分布式session、分布式锁
lua脚本保证多个操作的原子性

经典问题：
缓存穿透：大量相同请求查找数据时无法命中缓存，数据库也查不到，始终io（空值补充解决，加过期）
缓存击穿：一个热点数据失效，大量对该热点的请求并发查询数据库（通过互斥锁排队等待重建缓存）
缓存雪崩：大量数据过期失效，数据库瞬间压力变大（通过随机值让数据均匀过期）

优化：
多级缓存：本地缓存 - redis缓存 - database
缓存预热：在大流量到来把数据加载到redis中

持久化和高可用：
RDB快照：定期把内存数据考到硬盘，不安全但恢复快
AOF：记录每个操作，重新回放执行，恢复慢但安全
主从节点集群加哨兵机制保证多节点随时替换
-----------------------------------------------------------------------------------
正常类：
// Person 类已经存在
class Person {
void sayHello() {
System.out.println("Hello");
}
}

// 直接创建对象
Person p = new Person();  // 直接用现有的类创建对象
p.sayHello();  // 输出：Hello

匿名内部类：类不存在，直接实现接口或者继承一个类，生成对象

// 没有现成的类，临时创建一个类并立即使用
ActionListener listener = new ActionListener() {
@Override
public void actionPerformed(ActionEvent e) {
System.out.println("点击");
}
};  
button.addActionListener(listener);

这相当于：
// 1. 创建了一个没有名字的类
// 2. 这个类实现了 ActionListener 接口
// 3. 立即创建这个类的对象

lambda表达式：用于函数式接口，直接实现这个接口传入自己定义的方法

button.addActionListener(e -> System.out.println("点击"));
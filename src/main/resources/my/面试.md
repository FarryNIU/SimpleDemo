


# 登录篇
## 0. 说一下你怎么设计实现的用户身份认证
在项目中我基于JWT设置了用户的身份认证逻辑，具体是当用户进行登录时，程序中的网关模块进行密码校验，如果校验通过则在服务的生成一个JWT token，将这个token返回给
前端，此后前端每次发起其他业务请求都会携带这个token；服务端则使用spring mvc注册全局拦截器，在收到客户端请求后首先进行JWT token的合法性校验，如果校验通过
再真正进入到业务处理逻辑。

### 0.1 具体说说客户端请求的token放在请求的哪里？
JWT的token放在HTTP的请求头里面传递，放在参数Authorization Bearer的后面

### 0.2 你具体在注册拦截器验证token的时候是怎么做的
因为我的项目是基于Spring的，所以直接使用了Spring MVC提供的WebMvcConfigurer，具体是新建了一个类实现了WebMvcConfigurer接口，实现了addInterceptors方法，这个方法
就是Spring MVC指定用于实现全局拦截器的方法。在addInterceptors中注册了一个自定义的HandlerInterceptor，实现了里面的preHandle方法，这个方法是Spring MVC
拦截器链中的前置处理方法，在控制器方法执行前调用，所以可以在这里实现jwt的token验证，具体验证时重新使用token的header和payload加密钥计算生成signature，如果和客户端传来
的一致就判定通过。

## 1.你在设计登录时使用了JWT机制，什么是JWT
JWT是JSON Web Token，是一种标准，通常用于身份验证和信息交换。当用户进行登录时，服务端生成一个JWT token，将这个token返回给用户，此后用户每次请求都会携带JWT token，服务端会校验用户信息和token签名，从而实现服务端无状态的单点登录。

具体而言，JWT由三部分组成，分别是Header头部、Payload载荷、Signature签名，Header和Payload都是json格式数据进行base64编码得到，Signature是前两者的组合，经过服务器秘钥和算法的加密计算得到。
Header中主要存放使用哪种算法加密，以及声明token类型是JWT；
Payload中主要存放用户相关信息，如用户名id等

## 2.你在JWT中是怎么区分哪个用户的
解析Payload后查看用户信息即可

## 3.为什么要用JWT，有什么好处，不能直接用sessionId吗
JWT不需要服务器存储状态，只需要服务器存储一把秘钥，相对传统有状态的sessionID存储会方便很多，不需要每次查询比对token，因此节省了数据查询的io时间，适应分布式架构，不存在分布式系统token管理的问题；JWT可以扩展和定制，灵活性高

## 4.如何实现用户注销登录
如果是过期注销，可以使用内置的过期时间机制自动失效，确保token不是永久有效的，在payload中设置exp时间戳就可以了，这样服务器每次验证token时都会检查是否超时。

如果是用户主动注销，比较简单的做法是依赖前端，当客户注销登录时，前端把本地存储的JWT token删除，这样后续请求中就不会携带令牌，无法访问资源。如果追求更安全的方案，服务器可以维护一个token黑名单，如果用户发起注销则将token放入黑名单中，验证token时首先进行黑名单校验。黑名单后续等token过期或者用户重新登录时删除即可。

了解：单点登录SSO Single Sign-On，是指用户在一个应用的多个部分直接切换时，只需要登录一次，就可以访问该应用所有系统，不需要重复登录。具体实现通常使用token+认证中心的方式：用户访问系统时如果没有登录，那么就重定向到认证中心，认证中心让用户登录，登录后生成一个Token比如（JWT或者SessionID等），将Token或者秘钥存储在服务器，之后用户访问时携带这个Token，服务器来验证

## 5.你在数据库中怎么存储的密码
采用了MD5加密算法处理后进行的存储，防止密码明文存储易泄露

## 6.为什么用MD5加密，一定不会泄露吗
因为MD5算法是一种哈希算法，计算过程是不可逆的，生成散列值后就无法再还原得到原文。后续通过比对散列值来验证用户名密码，就不用担心密码泄露了。

目前并不是绝对安全的，之前MD5已经被破解，如果服务器被劫持还是有泄露风险，如果从加密的角度考虑，也可以替换为更安全的argon2等算法，核心思路都是一样的。同时也可以对登录增加双因素验证等方式加固，防止密文泄露也是比较关键的。

## 7.JWT中的数据为什么要用base64编码？
因为jwt使用http协议传输，服务器和浏览器解码可能会受一些特殊字符的影响，在把内容转换为base64编码时会替换一些特殊字符，可以避免因为特殊符号等格式解析问题带来的编解码错误，增强兼容性。同时这种编码是无损的，保证了数据的完整性

# 架构篇
## 1. 你在程序中是如何实现提升性能和高并发的
首先为了优化了程序中各种数据库查询操作，做了三级缓存，最常用的数据例如用户信息、咨询师信息等加载在程序内存中；可能被时常访问到的数据加载在redis缓存中，例如各咨询师可用时间信息、位置信息、已经预约信息等；其他查询不频繁的数据放在数据
库中，不加进缓存，例如历史评分记录、历史咨询记录等。


## 2. 你在项目中是怎么使用AOP编程的
AOP主要面向那些散布在系统各处，但是与那些具体业务功能无关的公共功能，在我的项目中的一个典型应用就是JWT用户鉴权的AOP编程，用户需要使用的所有接口都必须及进行JWT的token校验，因此对所有的业务方法设计了切面的前置通知，在具体业务执行
前验证jwt签名和有效期，同时也增加了异常通知，在捕获token异常时统一返回401状态码


# 限速篇
我在项目中实现了基于多层滑动窗口和令牌桶算法的分布式限速系统，支持动态调整策略，在模拟测试中成功抵御了脚本攻击，将恶意请求降低90%以上

## 1. 为什么要限速，简单介绍一下你限速的实现方式
如果不做限速，客户端可以通过脚本可以在短时间内发出大量请求，严重破坏预约的公平性；同时对于AI咨询，由于需要严格控制下游token的消耗，所以
需要对此类接口进行限速控制。
因此我设计了一个双层分布式限速系统，主要实现了用户级限速和业务级限速：
用户级通过滑动窗口实现限流，精确控制单位时间内的请求次数
业务级通过令牌桶实现限流，平滑限流曲线

### 1.2 具体怎么实现滑动窗口限速的
我在项目中基于Redis，在lua脚本中编写实现了滑动窗口算法，在程序中

## 2. 什么是lua脚本，为什么在redis中使用它
Lua是一种轻量级的脚本语言，Redis内置了Lua解释器。在Redis中使用Lua脚本主要是为了：
保证一系列操作的原子性：多个Redis命令组合执行，不会被其他命令打断
减少网络开销、提升性能：多个操作一次发送，减少网络往返，脚本在服务端执行，比客户端多次调用更快

在限流场景中，我用Lua脚本实现了滑动窗口算法，保证了计数器读取-判断-写入的原子性，防止数据出错

## 3. 既然你已经用了滑动窗口，为什么还要再用令牌桶限速
我采用双层限流主要是为了解决单一限流算法的局限性：
滑动窗口控制的维度是相对较长时间内的总量限制，但无法控制这期间请求的时间分布，恶意脚本可以在窗口开始瞬间用完所有配额，抢占资源。
那就需要再对瞬时流量进行控制，所以加入令牌桶限速，用来控制突发流量，它通过令牌积累机制，实现了：
允许合理突发（用户偶尔快速点击）
惩罚异常高频突发（脚本持续攻击）
两者结合的效果：
滑动窗口：确保30秒内最多10次
令牌桶：确保这10次请求合理分布 

## 4. 分布式环境下如何保证限速一致性？

## 5. 知道哪些限速限流算法，分别有什么区别
常用的限流算法主要有： 固定窗口、滑动窗口、漏桶、令牌桶
它们的主要区别在于：限速精度、允许突发、实现复杂度和适用场景。
# 介绍篇
## 1. 自我介绍
面试官您好，我是古心竹，目前在北京航空航天大学读研二，预计2027年毕业，目前主要是希望在咱们公司找一份日常实习，可以实习到明年的六七月份左右
然后我目前

## 2. 项目介绍
（心理咨询小程序是两个人一起完成的，你负责后端，不负责前端）
这个心理咨询小程序是B/S架构的程序，我主要负责开发后端部分，大体介绍一下的话
后端我使用Java基于SpringBoot开发，使用MySQL作为数据库，使用Redis作为缓存提升性能，使用RabbitMQ实现异步通信，解耦了网关模块和业务处理模块，然后实现了用户和咨询师的登录、咨询课程发布、以及核心的预约咨询等功能
在这个项目中，自己觉得做的比较好一些的部分，主要是为核心的预约业务，做了很多工作来保证它的高可用和高并发能力

# 登录篇
## 0. 说一下你怎么设计实现的用户身份认证
在项目中我基于JWT设置了用户的身份认证逻辑，具体是当用户进行登录时，程序中的网关模块进行密码校验，如果校验通过则在服务端生成一个JWT token，将这个token返回给
前端，此后前端每次发起其他业务请求都会携带这个token；服务端在controller层使用spring mvc来注册全局拦截器，在收到http请求后首先拦截进行前置处理，进行JWT token的合法性校验，如果校验通过
再真正进入到业务处理逻辑。

### 0.1 具体说说客户端请求的token放在请求的哪里？
JWT的token放在HTTP的请求头里面传递，参数的key叫Authorization，然后value中存放token

### 0.2 你具体在注册拦截器验证token的时候是怎么做的
因为我的项目是基于Spring的，所以直接使用了Spring MVC提供的WebMvcConfigurer，具体是新建了一个类实现了WebMvcConfigurer接口，实现了addInterceptors方法，这个方法
就是Spring MVC指定用于实现全局拦截器的方法。在addInterceptors中注册了一个自定义的HandlerInterceptor，实现了里面的preHandle方法，这个方法是Spring MVC
拦截器链中的前置处理方法，在控制器方法执行前调用，所以可以在这里实现jwt的token验证，具体验证时重新使用token的header和payload加密钥计算生成signature，如果和客户端传来
的一致就判定通过。

## 1.你在设计登录时使用了JWT机制，什么是JWT
JWT是JSON Web Token，是一种标准，通常用于身份验证和信息交换。当用户进行登录时，服务端生成一个JWT token，将这个token返回给用户，此后用户每次请求都会携带JWT token，服务端会根据客户token中的header和payload计算signature，计算后和客户传来的比对，校验token签名，
如果是一致的说明token是服务端签发的，没有过期的话就认为用户还处于登录状态，从而实现服务端无状态的登录。

具体而言，JWT由三部分组成，分别是Header头部、Payload载荷、Signature签名，Header和Payload都是json格式数据进行base64编码得到，Signature是前两者的组合，经过服务器秘钥和算法的加密计算得到。
Header中主要存放使用哪种算法加密，以及声明token类型是JWT；
Payload中主要存放用户相关信息，如用户名id等

## 2.你在JWT中是怎么区分哪个用户的
解析Payload后查看用户信息即可

## 3.为什么要用JWT，有什么好处，不能直接用sessionId吗
JWT不需要服务器存储状态，只需要服务器存储一把秘钥，相对传统有状态的sessionID存储会方便很多，不需要每次查询比对token，因此节省了数据查询的io时间，适应分布式架构，不存在分布式系统token管理的问题；JWT可以扩展和定制，灵活性高

## 4.如何实现用户注销登录
如果是过期注销，可以使用内置的过期时间机制自动失效，确保token不是永久有效的，在payload中设置exp时间戳就可以了，这样服务器每次验证token时都会检查是否超时。

如果是用户主动注销，比较简单的做法是依赖前端，当客户注销登录时，前端把本地存储的JWT token删除，这样后续请求中就不会携带令牌，无法访问资源。如果追求更安全的方案，服务器可以维护一个token黑名单，如果用户发起注销则将token放入黑名单中，验证token时首先进行黑名单校验。黑名单后续等token过期或者用户重新登录时删除即可。

## 5.你在数据库中怎么存储的密码
采用了MD5加密算法处理后进行的存储，防止密码明文存储易泄露

## 6.为什么用MD5加密，一定不会泄露吗
因为MD5算法是一种哈希算法，计算过程是不可逆的，生成散列值后就无法再还原得到原文。后续通过比对散列值来验证用户名密码，就不用担心密码泄露了。

目前并不是绝对安全的，之前MD5已经被破解，如果服务器被劫持还是有泄露风险，如果从加密的角度考虑，也可以替换为更安全的argon2等算法，核心思路都是一样的。同时也可以对登录增加双因素验证等方式加固，防止密文泄露也是比较关键的。

## 7.JWT中的数据为什么要用base64编码？
主要是方便传输，因为jwt使用http协议传输，服务器和浏览器解码可能会受一些特殊字符的影响，在把内容转换为base64编码时会替换为安全字符，可以避免因为特殊符号等格式解析问题带来的编解码错误，增强兼容性。同时这种编码是无损的，保证了数据的完整性

## 8.你在JWT中用的什么签名算法，是对称的还是非对称的，有什么区别？
项目中用到的是对称加密算法，HS256
对称算法使用同一把密钥进行加密和解密；而非对称算法使用一对互补的公钥和私钥，公钥加密私钥解，或者私钥加密公钥解；
对称算法速度快但密钥分发风险大，在分布式环境中，任何一个节点拿到私钥就可以用来签发token，
非对称算法用私钥签名，用公钥验，可以把私钥保存在单一的节点，其他节点只用公钥验证，安全性很高，但计算相对较慢

## 9.MAC 摘要算法是什么
MAC（Message Authentication Code 消息认证码）是一种带密钥的哈希函数，它通过将 密钥 与 消息 共同运算生成一个签名，用于验证数据的完整性，（确保没被改过）和真实性（确保是密钥持有者发的）。
与普通哈希（如 MD5）不同，黑客由于没有密钥，即便截获并篡改了消息，也无法伪造出匹配的 MAC 标签，从而在 HTTPS 和接口签名等场景中有效杜绝了中间人篡改
JWT的签名就属于MAC的应用

# 架构篇
## 1. 你在程序中是如何实现提升性能和高并发的
首先为了优化了程序中各种数据库查询操作，做了三级缓存，最常用的数据例如用户信息、咨询师信息等加载在程序内存中；可能被时常访问到的数据加载在redis缓存中，例如各咨询师可用时间信息、位置信息、已经预约信息等；其他查询不频繁的数据放在数据
库中，不加进缓存，例如历史评分记录、历史咨询记录等。

# AOP篇
## 1. 你在项目中是怎么使用AOP编程的
用AOP主要面向那些散布在各处，但是与那些具体业务功能无关的公共功能，在我的项目中的一个典型应用就是业务接口的流量限速，有些业务接口需要限制流量，因此通过对业务接口切面添加前置通知，在具体业务执行前
进行限速验证，通过后再进入正常业务逻辑

具体来说，我编写了一个自定义注解RateLimit，设置注解的生命周期是runtime等级，target设置为method，然后把限速用到的关键配置项，写为注解的成员变量。当使用注解时，将该注解注册在目标方法上，
并配置好限速参数。然后我通过aspect注解编写了一个切面类，设置切点为我的自定义注解注册到的所有方法（具体是在around注解中定义了annotation），使用环绕通知Around的方式，获取到切点信息ProceedingJoinPoint，
这里我需要的就是从ProceedingJoinPoint中获取MethodSignature中获取方法名，以及通过ProceedingJoinPoint的getArgs获取原本方法的入参，得到用户id，然后组合起来作为我的限速key，完成限速逻辑校验。通过后再
执行业务方法。


# MQ篇

## 1. 你在项目中怎么使用的rabbitmq
我在项目中使用RabbitMQ实现预约申请的异步通知功能，降低了网关模块与预约处理通知模块的耦合，
我的具体工作包括：
首先设计消息模型：设计了发起预约、预约成功等事件的消息格式；
然后通过依赖Spring Boot amqp，使用注解来编写消费者，使用RabbitTemplate编写生产者，
同时配置了手动确认模式确保消息不丢失，为预约消息超时功能配置了死信队列实现延迟效果，为生产者配置了ConfirmCallback回调确保消息到达Broker，消费者端添加了异常重试机制

## 2. 消息队列处理订单，如果消息丢失怎么办付
在rabbitmq中 ，主要通过消息确认机制确保消息的达到能够被感知到，而未确认的异常消息超时将放到死信队列中等待处理，不会被丢弃
同时消息队列本身也需要开启持久化，防止消息中间件重启后消息丢失
消息的确认机制主要有：生产者发往MQ的消息确认、MQ发往消费者的消息确认，以及消费者正确处理消息后的消息确认；
MQ本身消息的可靠性，对于rabbitMQ来说，可以将队列设置为持久化开启状态，或者使用stream队列
┌─────────┐    ┌──────────────┐    ┌─────────┐    ┌────────────┐
│ Producer│───▶│ 本地消息表    │───▶│   MQ    │───▶│ Consumer   │
└─────────┘    └──────────────┘    └─────────┘    └────────────┘
│                │                   │               │
│ Confirm回调     │ 定时任务扫描       │ 持久化+复制    │ 手动ACK
│ 重试机制        │ 重发未确认消息      │ 镜像队列      │ 消费记录
▼                ▼                   ▼               ▼
┌─────────────────────────────────────────────────────────────┐
│                     监控告警系统                            │
│  消息堆积监控 │ 失败率监控 │ 延迟监控 │ 死信监控              │
└─────────────────────────────────────────────────────────────┘
## 3. 消息队列处理订单，怎么确保消息不被重复消费的
在项目中，涉及非幂等操作的业务接口，我在网关就为发送到mq中的消息增加了一个request id，这个id是全局唯一的，在消费者进行消息消费时，需要检查request id是否
已经处理过，如果已经处理过则拒绝这次请求
# 限速篇
我在项目中实现了基于多层滑动窗口和令牌桶算法的分布式限速系统，支持动态调整策略，在模拟测试中成功抵御了脚本攻击，将恶意请求降低90%以上

## 1. 为什么要限速，简单介绍一下你限速的实现方式
一个是保护系统稳定性，防止因突发大流量导致服务不可用，
再就是对于核心的业务接口，例如预约功能，如果不做限速，客户端可以通过脚本可以在短时间内发出大量请求，严重破坏预约的公平性；同时对于AI咨询，由于需要严格控制下游token的消耗，所以
需要对此类接口进行限速控制。
因此我设计了一个双层分布式限速系统，主要实现了用户级限速和业务级限速：
例如在预约接口上面
用户级通过滑动窗口实现限流，主要精确控制单位时间内的请求次数，例如预约接口限速我们是每个用户每秒一次，AI咨询是每小时120次
业务级通过令牌桶实现限流，主要用来平滑限流曲线，因为滑动窗口不太能平滑流量的分布，所以是用了令牌桶来平滑那种瞬时的流量（例如预约接口令牌生成速率是500/秒，桶容量是800）


### 1.2 什么是令牌桶限速，介绍一下
令牌桶算法的是，建立一个用来装令牌的桶，系统以固定速率向桶中投放令牌，桶有最大容量，当桶满时新生成的令牌会被丢弃。
每当到来http请求时，需要消耗一个令牌才能被继续处理。
如果桶中有足够令牌，请求立即被处理；没有的话，就看作是超速拒绝，提示用户请求过于频繁。
这种算法允许突发流量，因为桶中积累的令牌可以一次性被消耗掉，同时也因为桶容量有限，所以可以平滑流量

### 1.3 什么是滑动窗口限速，介绍一下
滑动窗口算法是设置一个时间窗口，动态地统计最近一个窗口时间内的请求数量，设置一个最大请求数的阈值
当新请求到达时，算法会检查当前时间窗口内的请求总数是否超过阈值。
超过则说明超速需要拒绝请求。
窗口会随着时间向前滑动，自动移除旧的时间片数据。这种设计避免了固定窗口算法在窗口边界可能出现的双倍流量问题，提供了更精确和平滑的限流控制

### 1.4 具体怎么实现滑动窗口限速的
我在项目中基于Redis，在lua脚本中编写实现了滑动窗口算法，用Redis的有序集合（ZSET）配合Lua脚本来实现滑动窗口限流。
具体来说，需要把请求的userId当作key，当然userId前面加个滑动限速的命名空间
然后zset里面score是请求到来时对应的时间戳，member是请求id
当一个请求到来时，通过ZREMRANGEBYSCORE移除窗口外的数据，这个窗口外就是通过当前时间戳减去窗口时间，算出过期的时间点 
再用ZCARD统计当前窗口内的请求数，如果没有超过计数就插入新请求对应的时间戳。
整个过程封装在Lua脚本中保证原子性。


### 1.5 为什么用redis和lua脚本
使用redis可以天然的完成分布式限速，所有服务器节点都维护同一份限速数据，而使用lua脚本是为了保证上述操作的原子性，避免并发
安全问题，比如两个请求同时到来，同时看到未超速，结果瞬间通过了两次请求，就会超速，而redis是单线程模型，lua脚本在redis中
是单线程执行的，因此避免了这个安全问题

### 1.6 你的令牌桶限速是自己写的吗，怎么保证线程安全的
是的，其实也可以使用guava库的令牌桶，为了提高限流效率使用了无锁方案，线程安全是通过concurrentHashmap的compareAndSet保证的，compareAndSet会使用操作系统的CAS机制
（如 x86 的 CMPXCHG），在单个指令周期内完成比较和交换，不会被线程调度打断，保证令牌桶检查数值和设置数值的原子性，从而避免了
竞态条件

## 2. 什么是lua脚本，为什么在redis中使用它
Lua是一种轻量级的脚本语言，Redis内置了Lua解释器。在Redis中使用Lua脚本主要是为了：
保证一系列操作的原子性：多个Redis命令组合执行，不会被其他命令打断，在保证原子性后可以避免一些并发安全问题
同时也减少网络开销、提升性能：多个操作一次发送，减少网络往返，脚本在服务端执行，比客户端多次调用更快

在限流场景中，我用Lua脚本实现了滑动窗口算法，保证了计数器读取-判断-写入的原子性，防止并发时数据出错

## 3. 既然你已经用了滑动窗口，为什么还要再用令牌桶限速
主要是应用情景不同，核心功能对用户级别的限速我主要使用了滑动窗口，例如预约接口限速我们是每个用户每秒一次，AI咨询是每小时120次来控制风险
然后业务系统级别的限速主要用了令牌桶，用来平滑流量防止一瞬间被打垮，例如预约接口有整体系统限速每秒1000笔请求

## 4. 分布式环境下如何保证限速一致性？
通过使用redis+lua脚本

## 5. 知道哪些限速限流算法
常用的限流算法主要有： 固定窗口、滑动窗口、漏桶、令牌桶
它们的主要区别在于：限速精度、允许突发、实现复杂度和适用场景。


# 日志篇

## 1. 你在项目中如何管理日志的
在具体操作中，我使用了slf4j管理日志，底层引擎是spring boot默认的Logback，具体使用的时候通过lombok的slf4注解简化操作。
在日志管理时，根据slf4j的规范，主要把日志分为这几类：首先是最常用的info级日志，把所有的重要业务流水信息都记录在info中；其次是error级别，用来记录程序中出错的信息，这种错误可能是数据不符合预期，
或者是不符合正常业务逻辑等等，需要人特别关注的信息，可能影响正常运行的。最后是fetal信息，用来记录一定会影响程序正常运行的严重错误。除此之外也可以用warn和debug级别，但是我在项目中不是很常用

# 并发篇

## 1. 你在项目中有遇到并发问题吗，如果多个用户预约同一个课程，是如何避免超额预约的
有，如果当多个用户同时预约一个课程时，如果设计不当，可能遇到同一课程被多个用户预约的异常情况。
在项目中我使用了基于redis的分布式锁解决了这个并发问题， 
具体来说，首先项目中使用了redis高级客户端redisson，使用了RLock作为核心的锁机制，当一个请求到来时，首先需要去redis获取请求对应的课程的锁，这里的锁粒度是课程级的，不会阻塞其他课程的预约；
如果无法拿到锁，并且超过了获取锁的等待时间，那么本次任务失败，返回服务器繁忙消息，这个锁的等待时间也是通过redisson配置的；
如果拿到锁，相当于在redis中设置了一个key-value，同时设置了锁的最大持有时间，如果超时则自动释放锁，
拿到锁后，开始进行业务逻辑的操作，更新redis和mqsql中课程的状态，update为已被预约，mysql更新是为了做持久化。在这个过程中如果有任何一方更新失败，则回滚所有操作
当状态变更完成后，释放锁，这个过程相当于是删除之前的key-value，或者当锁被重入时是相当于进行计数器count down
通过上面的操作，最终可以多线程、分布式的情况下，课程都会被正确预约，并且严格的持久化在数据库中，一旦发生任何服务器异常，可以从数据库中恢复全部正确的状态

### 1.1 为什么要用可重入锁
为了防止同一个线程在持有锁的情况下，再次获取同一把锁时发生死锁

### 1.2 为什么要使用redis
这个问题的核心是保证课程扣减的原子性，在分布式环境下，我选择Redis实现，因为Redis性能特别高，能支撑高并发；二是由于Redis是单线程的，本身支持很多原子操作，

# 了解篇

## 1. template是什么（redisTemplate rabbitmqTemplate）
是模板的意思，源于模板方法设计模式(template method pattern)，体现出一种模板化的设计思想
在Spring中，一个template就代表一种封装了复杂资源操作的固定流程（模式），只需要对模式填写必要数据就可以使用，不用在乎具体繁琐流程
例如redisTemplate，就是封装了redis客户端向redis服务器建立连接发送消息的过程，
rabbitmq也是封装了创建连接、通道、交换机队列的步骤，只需要传参填写就可以使用

## 2. 字符串序列化和json序列化有什么区别
字符串序列化（String Serialization）
将对象转换为字符串（通常调用对象的toString()方法）。
存储的是字符串，没有结构信息。
读取时，需要自己解析字符串来重建对象。

JSON序列化（JSON Serialization）
将对象转换为JSON格式的字符串（例如使用Jackson库）。
存储的是结构化的数据，包括字段名和值。
读取时，可以通过JSON反序列化直接重建对象，包括类型信息（如果使用带有类型信息的JSON序列化器）。
